# -*- coding: utf-8 -*-
"""잠재요인기반_협업_필터링+개인맞춤화.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fiqdFvapuMueE5Zm53O9cPOCPx1Z67qq

##### ✅ ratings.csv -> user가 와인에 평가를 매긴 데이터
- userId
- wineId
- rating
  - 검색하기 (1점)
  - 클릭하기 (2점)
  - 저장하기 (3점)
  - 평가하기 (4점)
    - '그냥그래요' 선택 시 0점 기록 
    - ‘별로에요’ 선택 시 -1점 기록


##### ✅ wines.csv -> 와인정보 데이터
- wineImage
- wineName
- wineNameEng
- wineType
- winePrice
- wineSweet
- wineBody
- wineVariety
- aroma1,aroma2,aroma3
"""

import pandas as pd
import numpy as np
import numpy as np

#데이터 준비
rating_data = pd.read_csv('./ratings.csv')
wine_data = pd.read_csv('./wines.csv')

#사용자-와인 평점 데이터를 피봇 테이블 형식으로 바꿔줌
#사용자 별 각 와인 평점 방식으로 바꿔준 것
#n명의 사용자와 m개의 영화가 있으면 n x m 크기의 행렬이 만들어짐
df_user_wine_ratings = df_ratings.pivot(
    index = 'userId',
    columns = 'wineId',
    values = 'rating'
).fillna(0)

# matrix는 pivot_table 값을 numpy matrix로 만든 것
matrix = df_user_wine_ratings.as_matrix()

# user_ratings_mean은 사용자의 평균 평점
user_ratings_mean = np.mean(matrix, axis=1)

# R_user_mean : 사용자-영화에 대해 사용자 평균 평점을 뺀 것
matrix_user_mean = matrix - user_ratings_mean.reshape(-1, 1)

# n명의 사용자가 매긴 각각의 평균을 사용자 별로 빼준 상태
pd.DataFrame(matrix_user_mean, columns = df_user_movie_ratings.columns).head()

# scipy에서 제공해주는 svd
# U 행렬, sigma 행렬, V 전치 행렬 반환

U, sigma, Vt = svds(matrix_user_mean, k = 12)

# sigma 행렬은 0이 아닌 값만 1차원 행렬로 표현된 상태
# 0이 포함된 대칭행렬로 변환할 때는 numpy의 diag를 시용
sigma = np.diag(sigma)

"""## 잠재요인 기반 협업 필터링
1. 원본 user-wine 평점 행렬
2. 이를 user의 평균 점수를 빼서 matrix_user_mean 이라는 행렬로 만듬
3. 2번의 값을 SVD를 적용해서 U, Sigma, Vt 행렬을 구함
4. Sigma 행렬은 현재 0이 포함이 되지 않은 값으로만 구성되어 있음. 이를 대칭행렬로 변환

----현재상황----

- matrix_user_mean을 SVD를 적용해 분해를 한 상태
- 다시 원본 행렬로 복구시켜야 함 <br>
- U, Sigma, Vt의 내적을 수행
"""

# U, Sigma, Vt의 내적을 수행하면, 다시 원본 행렬로 복원
# 거기에 + 사용자 평균 rating을 적용
svd_user_predicted_ratings = np.dot(np.dot(U, Sigma), Vt) + user_ratings_mean.reshape(-1, 1)

df_svd_preds = pd.DataFrame(svd_user_predicted_ratings, columns = df_user_movie_ratings.columns)
df_svd_preds.head()

"""### 사용자 히스토리 기반 연관성 높은 와인추천 사용자 함수 생성
- 인자로 사용자 아이디, 와인 정보 테이블, 평점 테이블 받음
- 사용자 아이디에 SVD로 나온 결과의 와인 평점이 가장 높은 데이터 순으로 정렬
- 사용자가 본 데이터를 제외
- 사용자가 평가를 안 한 와인에서 평점이 높은 것을 추천
"""

def recommend_wine(df_svd_preds, user_id, ori_wines_df, ori_ratings_df, num_recommendations=5):

  #현재는 index로 적용이 되어있으므로 user_id -1
  user_row_number = user_id - 1

  #최종적으로 만든 pred_df에서 사용자 index 에 따라 영화 데이터 정렬 -> 와인 평정 높은 순으로 정렬
  sorted_user_predictions = df_svd_preds.iloc[user_row_number].sort_values(ascending=False)

  #원본 평점 데이터에서 user id에 해당하는 데이터를 뽑아냄
  user_data = ori_ratings_df[ori_ratings_df.userId == user_id]

  #위에서 뽑은 user_data와 원본 와인 데이터를 합침
  user_history = user_data.merge(ori_wines_df, on='wineId').sort_values(['rating'], ascending=False)

  #원본 와인 데이터에서 사용자가 평가한 와인 데이터를 제외한 데이터를 추출
  recommendations = ori_wines_df[~ori_wines_df['wineId'].isin(user_history['wineId'])]

  #사용자의 영화 평점이 높은 순으로 정렬된 데이터와 위 recommendations을 합침
  recommendations = recommendations.merge(pd.DataFrame(sorted_user_predictions).reset_index(), on = 'wineId')

  #컬럼 이름을 바꾸고 정렬해서 return
  recommendations = recommendations.rename(column = {user_row_number: 'Predictions'}).sort_values('Predictions',)

  return user_history, recommendations

already_rated, predictions = recommend_wine(df_svd_preds, 330, df_wines, df_ratings, 10)
already_rated.head()
